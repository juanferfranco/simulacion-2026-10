---
title: Unidad 6
unitId: unit6
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

<Aside type="note" title="Agentes aut√≥nomos y comportamiento emergente">

Continuando nuestro viaje por "The Nature of Code", nos adentramos en el fascinante mundo 
de los **agentes aut√≥nomos**. Estos son entidades que operan independientemente en 
un entorno, tomando decisiones basadas en un conjunto de reglas y en la percepci√≥n 
de su entorno (incluyendo otros agentes).

En esta unidad, exploraremos c√≥mo algunas reglas simples a nivel individual pueden dar lugar a 
comportamientos colectivos complejos y a menudo inesperados, un fen√≥meno conocido 
como **emergencia**. Nos centraremos en dos algoritmos clave presentados 
en "The Nature of Code": los **campos de flujo (flow fields)** y el **comportamiento de 
enjambre (flocking)**. 
</Aside>

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

<Aside type="tip" title="Objetivos de aprendizaje">
Al finalizar esta unidad, ser√°s capaz de:

- Describir el concepto de agente aut√≥nomo y comportamiento emergente en el contexto del arte generativo.
- Analizar y explicar el funcionamiento de los algoritmos de campos de flujo (flow fields) y comportamiento 
de enjambre (flocking) presentados en "The Nature of Code".
- Identificar los par√°metros clave que controlan el comportamiento de los agentes en ambos algoritmos.
- Implementar un sketch interactivo en p5.js que utilice flow fields o flocking.
- Aplicar creativamente uno de estos algoritmos.
</Aside>

### Actividad 01

En esta actividad propondr√© que te encuentres de nuevo el trabajo de [Tyler Hobbs](https://youtu.be/8tTGJvijoDw?si=7KWuEhMTIjH41JOj) y 
espec√≠ficamente que mires [su art√≠culo sobre campos de flujo](https://www.tylerxhobbs.com/words/flow-fields).

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
- Captura en tu bit√°cora dos im√°genes de Tyler Hobbs que te llamen la atenci√≥n y explica por qu√©.
- ¬øQu√© te inspira de su trabajo?
:::

## Seek: Investigaci√≥n üîé

<Aside type="note" title="Analizando los algoritmos">
Vamos a sumergirnos en el c√≥digo y la l√≥gica detr√°s de los campos de flujo y el 
comportamiento de enjambre, utilizando los ejemplos de "The Nature of Code" como 
punto de partida. El objetivo es entender *c√≥mo* funcionan internamente.
</Aside>

### Actividad 02

En esta actividad quiero que investigues alrededor de estas dos preguntas:

1. ¬øQu√© es una fuerza de direcci√≥n (steering force)?
2. ¬øQu√© diferencia tiene este tipo de fuerza con las que ya hemos estudiado en el contexto de la simulaci√≥n de agentes?
3. ¬øQu√© relaci√≥n tiene la steering force con Craig Reynolds y su trabajo en simulaci√≥n de comportamiento animal?

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Documenta tus hallazgos en tu bit√°cora.
:::

### Actividad 03

:::note[üéØ Enunciado]
Vamos a analizar el primer algoritmo clave: los campos de flujo (Flow Fields), bas√°ndonos en el ejemplo del libro "The Nature of Code". 
Entenderemos c√≥mo una cuadr√≠cula de vectores dirige el movimiento de los agentes.
:::

:::tip[Recursos]
-   Libro "The Nature of Code" (TNoC) de Daniel Shiffman: [Cap√≠tulo 5, secci√≥n "Flow Fields"](https://natureofcode.com/autonomous-agents/#flow-fields) 
(y ejemplos de c√≥digo asociados).
-   El c√≥digo fuente del ejemplo de Flow Fields de TNoC.
:::

**Pasos**:

1.  **Ejecuta el ejemplo:** ejecuta el c√≥digo del ejemplo principal de Flow Fields de TNoC en p5.js. Observa el comportamiento de los veh√≠culos/agentes.
2.  **Identifica la estructura del campo:** en el c√≥digo (usualmente en una clase `FlowField`), localiza c√≥mo se almacena el campo de flujo. ¬øQu√© estructura de 
datos se usa (ej: un array 2D)? ¬øQu√© representa cada elemento de esa estructura? ¬øC√≥mo se calcula inicialmente el vector en cada punto?
3.  **Analiza el comportamiento del agente:** en el c√≥digo de la clase del veh√≠culo/agente (`Vehicle`), encuentra la funci√≥n `follow()`. Explica con tus palabras:
    *   ¬øC√≥mo determina el agente qu√© vector del campo de flujo debe seguir bas√°ndose en su posici√≥n actual? (pista: implica mapear la posici√≥n a √≠ndices de la cuadr√≠cula).
    *   Una vez que tiene el vector deseado del campo, ¬øC√≥mo lo utiliza para calcular la fuerza de direcci√≥n (`steering force`)? 
    (pista: implica calcular la diferencia con la velocidad actual y limitar la fuerza).
4.  **Identifica par√°metros clave:** localiza en el c√≥digo las variables que controlan aspectos importantes como:
    *   La resoluci√≥n del campo de flujo (el tama√±o de las celdas de la cuadr√≠cula).
    *   La velocidad m√°xima (`maxspeed`) y la fuerza m√°xima (`maxforce`) de los agentes.
5.  **Experimenta con modificaciones:** realiza al menos **una** de las siguientes modificaciones en el c√≥digo, ejecuta y describe el efecto observado en el comportamiento de los agentes:
    *   Cambia significativamente la forma en que se generan los vectores del campo (ej: usa una f√≥rmula matem√°tica diferente en lugar de `noise()`, o cambia dr√°sticamente los par√°metros de `noise()`).
    *   Modifica sustancialmente la resoluci√≥n del campo de flujo (hazla mucho m√°s fina o mucho m√°s gruesa).
    *   Altera considerablemente `maxspeed` o `maxforce` de los agentes.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
1. Explica brevemente la estructura de datos usada para el campo de flujo y c√≥mo se generan sus vectores.
2. Describe con tus palabras c√≥mo un agente utiliza el campo para calcular su fuerza de direcci√≥n.
3. Lista los par√°metros clave identificados (resoluci√≥n, maxspeed, maxforce).
4. Describe la modificaci√≥n que realizaste al c√≥digo y **explica detalladamente el efecto** que tuvo en el movimiento y comportamiento colectivo de los agentes. Incluye una captura de pantalla o GIF si ilustra bien el cambio. Muestra el fragmento de c√≥digo modificado.
:::

### Actividad 04

:::note[üéØ Enunciado]
Ahora analizaremos el segundo algoritmo: el comportamiento de enjambre (Flocking), 
famoso por simular el movimiento coordinado de p√°jaros o peces. Nos basaremos nuevamente en 
"The Nature of Code" para entender las tres reglas b√°sicas que lo gobiernan.
:::

:::tip[Recursos]
-   Libro "The Nature of Code" (TNoC) de Daniel Shiffman: [cap√≠tulo 5, secci√≥n "Flocking"](https://natureofcode.com/autonomous-agents/#flocking) (y ejemplos de c√≥digo asociados).
-   El c√≥digo fuente del ejemplo de Flocking de TNoC.
:::

**Pasos**:

1.  **Ejecuta el ejemplo:** ejecuta el c√≥digo del ejemplo principal de Flocking de TNoC en p5.js. Observa el movimiento colectivo de los "boids" (agentes).
2.  **Identifica las tres reglas:** en el c√≥digo de la clase del agente (ej: `Boid`), localiza las funciones que implementan las tres reglas fundamentales del Flocking:
    *   **Separaci√≥n (Separation):** evitar el hacinamiento con vecinos cercanos.
    *   **Alineaci√≥n (Alignment):** dirigirse en la misma direcci√≥n promedio que los vecinos cercanos.
    *   **Cohesi√≥n (Cohesion):** moverse hacia la posici√≥n promedio de los vecinos cercanos.
3.  **Explica las reglas:** para cada una de las tres reglas, explica con tus propias palabras:
    *   ¬øCu√°l es el objetivo de la regla?
    *   ¬øC√≥mo calcula el agente la fuerza de direcci√≥n correspondiente? (describe la l√≥gica general, ej: "Calcula un vector apuntando lejos de los vecinos demasiado cercanos").
4.  **Identifica par√°metros clave:** localiza en el c√≥digo las variables que controlan:
    *   El radio (o distancia) de percepci√≥n (`perceptionRadius` o similar) que define qui√©nes son los "vecinos". A veces tambi√©n hay un √°ngulo de percepci√≥n.
    *   Los pesos o multiplicadores que determinan la influencia relativa de cada una de las tres reglas al combinarlas.
    *   La velocidad m√°xima (`maxspeed`) y la fuerza m√°xima (`maxforce`) de los agentes (similar a Flow Fields).
5.  **Experimenta con modificaciones:** realiza al menos **una** de las siguientes modificaciones en el c√≥digo, ejecuta y describe el efecto observado en el comportamiento *colectivo* del enjambre:
    *   Cambia dr√°sticamente el peso de una de las reglas (ej: pon la cohesi√≥n a cero, o la separaci√≥n muy alta).
    *   Modifica significativamente el radio de percepci√≥n (hazlo muy peque√±o o muy grande).
    *   Introduce un objetivo (`target`) que todos los boids intenten seguir (usando una fuerza de `seek`) adem√°s de las reglas de flocking, y ajusta su influencia.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
1. Explica con tus palabras el objetivo y la l√≥gica general de c√°lculo de cada una de las tres reglas de Flocking (Separaci√≥n, Alineaci√≥n, Cohesi√≥n).
2. Lista los par√°metros clave identificados (radio de percepci√≥n, pesos de las reglas, maxspeed, maxforce).
3. Describe la modificaci√≥n que realizaste al c√≥digo y **explica detalladamente el efecto** que tuvo en el comportamiento *colectivo* del enjambre (¬øSe dispersan? 
¬øForman grupos compactos? ¬øse mueven ca√≥ticamente?). Incluye una captura de pantalla o GIF si ilustra bien el cambio. Muestra el fragmento de c√≥digo modificado.
:::


## Apply: Aplicaci√≥n üõ†

<Aside type="note" title="Creaci√≥n generativa con un giro inesperado">
Ahora que entiendes los algoritmos, es tu turno de crear. Aplicar√°s uno de ellos 
(flow fields o flocking) para generar una pieza de arte interactivo que permita visualizar un tema 
musical de tu elecci√≥n. La interacci√≥n del usuario debe influir en el comportamiento de los agentes.
</Aside>

### Actividad 05

1. Elige un tema musical que te inspire.
2. Dise√±a una pieza de arte generativo que utilice el algoritmo de flow fields y/o flocking.
3. Vas a visualizar el tema musical y adem√°s vas a "tocar" las visuales, es decir, tu pieza de arte debe ser interactiva y 
debe permitir la interpretaci√≥n en tiempo real de las visuales como si fuera un instrumento m√°s que acompa√±a de manera coherente 
el tema musical.


:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
1. Documenta todo el proceso de dise√±o y creaci√≥n en tu bit√°cora, incluyendo bocetos y decisiones de dise√±o.
2. El c√≥digo fuente completo de tu sketch en p5.js.
3. Un enlace a tu sketch en el editor de p5.js.
4. Capturas de pantalla mostrando tu pieza en acci√≥n.
:::

## Evidencias üóÇÔ∏è

<Aside type="note" title="RUBRICA!">
* Recuerda que la bit√°cora se cierra 10 minutos antes de iniciar la sesi√≥n de evaluaci√≥n de la unidad (segunda sesi√≥n de la segunda semana).
plasma en la bit√°cora. La bit√°cora no es un resultado que se llena a √∫ltima hora.
* Si no realizas la autoevaluaci√≥n tu nota ser√° 0.
* Si una actividad no est√° COMPLETA debes multiplicar la nota de esa actividad por el porcentaje de avance que tengas.
* Puedes usar IA generativa para generar c√≥digo, **pero NO para DISE√ëAR**. 

**R√∫brica de evaluaci√≥n del proceso**

5: realic√© las 5 actividades completas y la autoevaluaci√≥n.  
4: realic√© 4 actividades completas y la autoevaluaci√≥n.  
3: realic√© 3 actividades completas y la autoevaluaci√≥n.  
2: realic√© 2 actividades completas y la autoevaluaci√≥n.  
1: realic√© 1 actividad completa y la autoevaluaci√≥n.  
0: no realic√© ninguna actividad o no realic√© la autoevaluaci√≥n.  
</Aside>

<Aside type="danger" title="EVIDENCIAS EN BIT√ÅCORA">

1. Realiza las actividades propuestas en esta unidad y documenta todo el proceso en tu bit√°cora.
2. Realiza la autoevaluaci√≥n indicando:
    * Tu nota propuesta.
    * La defensa de esa nota para cada actividad. 
</Aside>

## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

1. Explica en tus propias propias palabras qu√© es un agente aut√≥nomo y c√≥mo puede contribuir al arte generativo.
2. ¬øQu√© es el comportamiento emergente y c√≥mo se manifiesta en los algoritmos de flow fields y flocking?
3. Para los m√°s curisos. ¬øPuedo aplicar lo que aprend√≠ en esta unidad en Blender? Te dejo un [video](https://youtu.be/eqLA7oJkLyM?si=s97HHI8vErOxSDO5) para 
que te antojes y si creas algo en Blender ¬øMe muestras?
